% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ngr_dbqs_filter_predicate.R
\name{ngr_dbqs_filter_predicate}
\alias{ngr_dbqs_filter_predicate}
\title{Construct a SQL Query Using Spatial Predicates}
\usage{
ngr_dbqs_filter_predicate(
  target_tbl,
  mask_tbl,
  target_col_return = "*",
  mask_col_return = NULL,
  mask_col_filter = NULL,
  mask_col_filter_values = NULL,
  mask_col_filter_values_negate = FALSE,
  function_spatial = "ST_Intersects",
  quote_tbl = FALSE,
  ...
)
}
\arguments{
\item{target_tbl}{\link{character} The name of the target table. Required.}

\item{mask_tbl}{\link{character} The name of the mask table. Required.}

\item{target_col_return}{\link{character} Columns to return from the target table. Default is '*', meaning all columns.}

\item{mask_col_return}{\link{character} Columns to return from the mask table. Default is \code{NULL}, meaning no columns are returned.}

\item{mask_col_filter}{\link{character} The column from the mask table used for filtering. Default is \code{NULL}.}

\item{mask_col_filter_values}{\link{character} Values to filter the mask column by. Default is \code{NULL}.}

\item{mask_col_filter_values_negate}{\link{logical} Whether to negate the filter condition for the mask column. Default is \code{FALSE}.}

\item{function_spatial}{\link{character} The spatial function to use for filtering, e.g., "ST_Intersects". Default is "ST_Intersects". Valid options are:
\itemize{
\item \code{ST_Intersects}
\item \code{ST_Contains}
\item \code{ST_Within}
\item \code{ST_Overlaps}
\item \code{ST_Crosses}
\item \code{ST_Touches}
}

For more details on spatial functions, see
\href{https://postgis.net/docs/using_postgis_query.html#:~:text=To\%20make\%20it\%20easy\%20to,\%2C\%20ST_Overlaps\%2C\%20ST_Touches\%2C\%20ST_Within.}{PostGIS Query Functions}.}

\item{quote_tbl}{\link{logical} Whether to quote table names to handle special characters. Default is \code{FALSE}. Allows
quoting to be adjusted so can be used in geopackage when table names have periods in them.  Uses \code{\link[=ngr_dbqs_tbl_quote]{ngr_dbqs_tbl_quote()}} to quote table names.}

\item{...}{Additional arguments passed to \code{ngr::ngr_fdb_tbl_quote()} if \code{quote_tbl} is \code{TRUE}.}
}
\value{
\link{character} A SQL query string.
}
\description{
This function generates a SQL query to filter and join tables based on spatial predicates. Should work on any SQL
database that supports spatial functions.
}
\details{
To enable geopackage support:
\enumerate{
\item Install spatialite-tools on cmd line with

\verb{brew install spatialite-tools}
\item Find your installation on cmd line with

\verb{find /opt/homebrew -name mod_spatialite.dylib}
\item Then Connect to GeoPackage in R with

\code{con <- DBI::dbConnect(RSQLite::SQLite(), path_to_gpkg)}
\item Load SpatiaLite

\code{dbExecute(con, "SELECT load_extension('/opt/homebrew/lib/mod_spatialite.dylib');")}
\item Run queries with

\code{DBI::dbGetQuery(con, query = ngr_dbqs_filter_predicate(blah, blah, blah, quote_tbl = TRUE))}
}
}
\examples{
ngr_dbqs_filter_predicate(
  target_tbl = "target_table",
  mask_tbl = "mask_table",
  target_col_return = c("col1", "col2"),
  mask_col_return = c("filter_col"),
  mask_col_filter = "filter_col",
  mask_col_filter_values = c("value1", "value2"),
  function_spatial = "ST_Intersects"
)

}
\concept{spatial}
