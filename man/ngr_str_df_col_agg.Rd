% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ngr_str_df_col_agg.R
\name{ngr_str_df_col_agg}
\alias{ngr_str_df_col_agg}
\title{Aggregate Numeric Columns by Row}
\usage{
ngr_str_df_col_agg(
  dat,
  col_str_match,
  col_result,
  fun = "mean",
  col_str_negate = NULL,
  decimal_places = 1
)
}
\arguments{
\item{dat}{\link{data.frame} or \link{sf} object. The input data.}

\item{col_str_match}{\link{character} A string to match column names for aggregation.}

\item{col_result}{\link{character} The name of the resulting column with aggregated values.}

\item{fun}{\link{character} The aggregation function to use. Options are "mean", "sum", "median", "min", or "max". Default is "mean".}

\item{col_str_negate}{\link{character} (Optional) A string to exclude matching columns from aggregation. Default is \code{NULL}.}

\item{decimal_places}{\link{numeric} Number of decimal places for rounding. Default is 1.}
}
\value{
The input \code{dat} with a new column named \code{col_result} containing aggregated values.
}
\description{
This function aggregates numeric columns in a data frame or \code{sf} object by rows based on a specified aggregation function (e.g., \code{\link[=mean]{mean()}}, \code{\link[=sum]{sum()}}, \code{\link[=median]{median()}}). It allows column inclusion/exclusion using string matching and supports rational rounding.
}
\details{
This function identifies numeric columns matching \code{col_str_match} while excluding those matching \code{col_str_negate}, applies the specified aggregation function row-wise, and attaches the result as a new column in the input data.

Rounding is performed using rational rounding (e.g., 1.55 rounds to 1.6).
}
\examples{
# Load example data
path <- system.file("extdata", "form_fiss_site_2024.gpkg", package = "ngr")

dat_raw <- sf::st_read(path, quiet = TRUE)

col_str_negate = "time|method|avg|ave"
col_str_to_agg <- c("channel_width", "wetted_width", "residual_pool", "gradient", "bankfull_depth")
columns_result <- c("avg_channel_width_m", "avg_wetted_width_m", "average_residual_pool_depth_m", "average_gradient_percent", "average_bankfull_depth_m")

# Initialize dat as a copy of dat_raw to preserve the original and allow cumulative updates
dat <- dat_raw

# Use mapply with cumulative updates
# Suppress mapply output by assigning it to invisible
invisible(mapply(
  FUN = function(col_str_match, col_result) {
    # Update dat cumulatively
    dat <<- ngr_str_df_col_agg(
      dat = dat,  # Use the updated dat for each iteration
      col_str_match = col_str_match,
      col_result = col_result,
      col_str_negate = col_str_negate,
      decimal_places = 1
    )
  },
  col_str_match = col_str_to_agg,
  col_result = columns_result
))

# Print the first few rows of the resulting data after subsetting and dropping geom
dat_no_geom <- as.data.frame(dat)
dat_subset <- dat_no_geom[1:5, grep("average|avg", names(dat_no_geom))]
head(dat_subset)
\dontrun{

# Use purrr::reduce with cumulative updates
dat <- purrr::reduce(
  .x = seq_along(col_str_to_agg),
  .f = function(acc_df, i) {
    ngr_str_df_col_agg(
      dat = acc_df,
      col_str_match = col_str_to_agg[i],
      col_result = columns_result[i],
      col_str_negate = col_str_negate,
      decimal_places = 1
    )
  },
  .init = dat_raw
)

# Print the first few rows of the resulting data
# Convert to a plain data.frame
dat_no_geom <- as.data.frame(dat)
dat_subset <- dat_no_geom[1:5, grep("average|avg", names(dat_no_geom))]
head(dat_subset)
}
}
\seealso{
\code{\link[=mean]{mean()}}, \code{\link[=sum]{sum()}}, \code{\link[=median]{median()}}, \code{\link[=min]{min()}}, \code{\link[=max]{max()}}

Other string dataframe: 
\code{\link{ngr_str_df_detect_filter}()}
}
\concept{string dataframe}
