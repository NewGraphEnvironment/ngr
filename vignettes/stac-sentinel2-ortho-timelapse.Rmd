---
title: "STAC ortho timelapse"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{STAC ortho timelapse}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  # echo = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ngr)
```

## Planetary Computer Collections

The [Microsoft Planetary Computer](https://planetarycomputer.microsoft.com/) hosts
a STAC catalog with numerous Earth observation datasets. We can use `rstac` to
query the available collections directly from the API:

```{r pc-collections}
stac_url <- "https://planetarycomputer.microsoft.com/api/stac/v1"

# Fetch all collections from the Planetary Computer STAC catalog
collections <- rstac::stac(stac_url) |>
  rstac::collections() |>
  rstac::get_request()

# determin which dtasets overlap bc
# bc_bbox <- c(-139, 48, -114, 60)

 #100km buffer from the us border to not overlap all the us dtasets 
bc_bbox <- c(-139, 49.5, -114, 60)

bc_overlap <-  purrr::keep(collections$collections, ~ {

  bbox <- .x$extent$spatial$bbox[[1]]
  bbox[1] <= bc_bbox[3] && bbox[3] >= bc_bbox[1] &&
   bbox[2] <= bc_bbox[4] && bbox[4] >= bc_bbox[2]
  }) |>
  purrr::map_chr("id")

# Extract collection IDs and descriptions into a data frame
collections_df <- purrr::map_df(collections$collections, ~ {
    interval <- .x$extent$temporal$interval[[1]]
    data.frame(
      id = .x$id,
      start = interval[[1]],
      end = interval[[2]],
      description = paste0(.x$title, ": ", paste(.x$keywords %||% NA_character_, collapse = ", ")),
      check.names = FALSE
    )
  }) |>
    dplyr::mutate(
      start = as.Date(start),
      end = as.Date(end),
      # rowid = dplyr::row_number(),
      bc_overlap = dplyr::if_else(id %in% bc_overlap, "yes", "no"), .after = id
    ) |> 
  dplyr::arrange(id)


collections_df |> 
  kableExtra::kbl() |> 
  kableExtra::scroll_box(width = "100%", height = "500px") |> 
  kableExtra::kable_styling(c("condensed", 
        "responsive"), full_width = T, font_size = 10)
```

For more details on each collection, visit the
[Planetary Computer Data Catalog](https://planetarycomputer.microsoft.com/catalog).

This vignette demonstrates computing NDVI from Landsat imagery using STAC APIs. The
`ngr_spk_stac_calc()` function provides a simple proof-of-concept approach using
`terra`. For production workflows involving time series, composites, or data cubes,
see the [gdalcubes](https://github.com/appelmar/gdalcubes) package.

## Single Year Example

Define an area of interest and query the Planetary Computer STAC catalog for
Landsat Collection 2 Level-2 imagery with low cloud cover.

```{r rstac-query-2016}
# Define an AOI from a bounding box (WGS84) - Maxxam floodplain near bulkley lake
bbox <- c(
  xmin = -126.17545256019142,
  ymin =  54.36161045287439,
  xmax = -126.12615394008702,
  ymax =  54.38908432381547
)


aoi <- sf::st_as_sfc(sf::st_bbox(bbox, crs = 4326)) |>
  sf::st_as_sf()

stac_url <- "https://planetarycomputer.microsoft.com/api/stac/v1"
y <- 2016
date_time <- paste0(y, "-05-01/", y, "-09-15")

stac_query <- rstac::stac(stac_url) |>
  rstac::stac_search(
    collections = "sentinel-2-l2a",
    datetime = date_time,
    intersects = sf::st_geometry(aoi)[[1]],
    limit = 200
  ) |>
  rstac::ext_filter(`eo:cloud_cover` <= 20)

items <- stac_query |>
  rstac::post_request() |>
  rstac::items_fetch() |>
  rstac::items_sign_planetary_computer()

```

Clip "visual" item to the bbox aoi

```{r clip-2016}
# items$features is a list of items, but the function expects a single item so we either
# Use purrr::map() to process each feature or access a single feature directly
r <- items$features[[1]] |> 
  ngr_spk_stac_calc(asset_a = "visual", asset_b = NULL, calc = NULL, aoi = aoi)

```

Create a mapview object for each NDVI raster with a red-yellow-green color scale.

```{r mapview1}
leaflet::leaflet() |>
  leaflet::addTiles() |>
  leafem::addRasterRGB(r, quantiles = c(0.02, 0.98))

# static view
# terra::plotRGB(r, stretch = "lin")

```

## Native Resolution RGB

The "visual" asset is a pre-rendered RGB that may be compressed. For higher
resolution, we can build an RGB composite from the native 10m bands (B04=Red,
B03=Green, B02=Blue).

```{r rgb-native}
r_rgb <- items$features[[1]] |>
  ngr_spk_stac_calc(
    asset_a = "B04",
    asset_b = "B03",
    asset_c = "B02",
    calc = "rgb",
    aoi = aoi
  )
```

Compare the pre-rendered "visual" asset (left) with native 10m bands (right):

```{r rgb-plot, fig.width=10, fig.height=5}
par(mfrow = c(1, 2))
terra::plotRGB(r, stretch = "lin", main = "Visual Asset")
terra::plotRGB(r_rgb, stretch = "lin", main = "Native 10m RGB")

```


They look basically identical and when we check the resolution we can see that they are equal...

```{r res-compare}
# compare the resolution
terra::res(r)
terra::res(r_rgb)
```

## Multi-Year Comparison

Query multiple years and retrieve the latest available ortho (visual asset) from
peak growing-season for each year.

```{r multi-year, eval=T}
years <- seq(2016, 2025, by = 1)

orthos_by_year <- years |>
  purrr::map(function(y) {
    date_time <- paste0(y, "-06-01/", y, "-07-31")

    items <- rstac::stac(stac_url) |>
      rstac::stac_search(
        collections = "sentinel-2-l2a",
        datetime = date_time,
        intersects = sf::st_geometry(aoi)[[1]],
        limit = 10
      ) |>
      rstac::ext_filter(`eo:cloud_cover` <= 20) |>
      rstac::post_request() |>
      rstac::items_fetch() |>
      rstac::items_sign_planetary_computer()

    # Return NULL if no features found for this year
    if (length(items$features) == 0) return(NULL)

    # Sort by datetime descending to get the latest scene
    datetimes <- purrr::map_chr(items$features, ~ .x$properties$datetime)
    latest_idx <- which.max(as.POSIXct(datetimes))

    # Extract the acquisition date for the layer name
    acq_date <- as.Date(datetimes[latest_idx])

    # Get the latest feature's visual asset clipped to AOI
    ortho <- items$features[[latest_idx]] |>
      ngr_spk_stac_calc(asset_a = "visual", asset_b = NULL, calc = NULL, aoi = aoi)

    list(date = acq_date, raster = ortho)
  }) |>
  purrr::compact() |>  # Remove NULLs (years with no data)
  (\(x) purrr::set_names(x, purrr::map_chr(x, ~ as.character(.x$date))))()
```

Display the multi-year comparison as toggleable layers on a leaflet map.

```{r map2, out.width="100%", eval=T}
map <- leaflet::leaflet() |>
  leaflet::addTiles()

for (dt in names(orthos_by_year)) {
  map <- map |>
    leafem::addRasterRGB(orthos_by_year[[dt]]$raster, group = dt, quantiles = c(0.02, 0.98))
}

map |>
  leaflet::addLayersControl(
    baseGroups = names(orthos_by_year),
    options = leaflet::layersControlOptions(collapsed = FALSE)
  )
```

